end when x meals have been eaten,
free all mallocs

-- Cleanup checklist (what needs to be freed/destroyed) --

1) data->forks (allocated)
	- File: src/init.c
	- Line: data->forks = malloc(sizeof(pthread_mutex_t) * data->rules.philos); (around line 37)
	- Action: For i in 0..philos-1: pthread_mutex_destroy(&data->forks[i]); then free(data->forks);

2) data->philos (allocated)
	- File: src/init.c
	- Line: data->philos = malloc(sizeof(t_philo) * data->rules.philos); (around line 53)
	- Action: After all philosopher threads and monitor thread have been joined, call free(data->philos);

3) Fork mutexes (initialized)
	- File: src/init.c
	- Line: if (pthread_mutex_init(&data->forks[i], NULL) != 0) clean_exit(1); (around line 43)
	- Action: Destroy each with pthread_mutex_destroy before freeing the forks array.

4) print_mutex and death_mutex (initialized)
	- File: src/init.c
	- Lines: pthread_mutex_init(&data->rules.print_mutex, NULL) and pthread_mutex_init(&data->rules.death_mutex, NULL) (around lines 26-28)
	- Action: Call pthread_mutex_destroy(&data->rules.print_mutex) and pthread_mutex_destroy(&data->rules.death_mutex) during cleanup.

5) Threads
	- Files: src/threads.c (thread creation and join)
	- Action: Ensure all philosopher threads (data->philos[i].thread_id) and the monitor thread (data->monitor_thread) are joined before destroying mutexes and freeing memory. Use pthread_join where appropriate.

6) clean_exit
	- File: src/end.c
	- Current: clean_exit(int error) just calls exit(error);
	- Action: Implement a proper cleanup sequence in clean_exit (or a separate cleanup function) that:
		 a) sets a flag so threads stop (if needed),
		 b) joins philosopher threads and monitor thread,
		 c) destroys fork mutexes,
		 d) destroys print/death mutexes,
		 e) frees data->philos and data->forks,
		 f) exits with the provided code.

Notes / safety
 - Only destroy mutexes and free memory after threads have stopped/joined. Destroying a mutex while another thread may use it is undefined behavior.
 - Make clean_exit safe to call at any point (track what was initialized and only destroy/free those items).
 - There are no other malloc/free calls in this project (only the two allocations above). If you add dynamic resources later, update the checklist accordingly.

Example cleanup order (high-level):
 - signal threads to stop (set rules.someone_died or a separate flag)
 - join all philosopher threads
 - join monitor thread
 - destroy fork mutexes
 - destroy print and death mutexes
 - free data->forks
 - free data->philos
 - exit

If you want I can implement the `clean_exit` function for you (with partial-init safety) and run a quick smoke test. Or you can use the checklist above to implement it yourself.